#!/usr/bin/python3
"""@package docstring
Documentation for agwb.py module

Written by Wojciech M. Zabolotny
wzab01<at>gmail.com 18-20.06.2019
added support for extended interface:
wzab01<at>gmail.com 2.02.2021
changed support for extended interface, according
to proposal of Walter F.J. MÃ¼ller
w.f.j.mueller<at>gsi.de 4.02.2021

The agwb.py module is a helper that provides
access to hierarchy of blocks/registers/bitfields
generated by addr_gen_wb environment, from
the pure Python code, via a simple interface.
The interface must provide two methods:

read(self,address) that returns 32-bit value
write(self,address,value) that writes such a value

The extended interface (with cached write and read
accesses and support for optimized bitfields
handling and read-modify-write) should provide
additional methods:

writeb(self,address,value) - that only schedules
       a write (unless the operation list is full)
readb(self,address) - that returns the "Callable"
       object. Calling the returned object returns
       the value (possibly triggering dispatch if necessary)
write_masked(self,address,mask,value) - executes the read-modify-write
       operation defined as follows
       X:= (X and ~mask) | (value and mask)
       the operation should be handled in the FPGA.
writeb_masked(self,address,mask,value, more=False)
       Prepares the read-modify-write operation defined as follows
       X:= (X and ~mask) | (value and mask)
       Setting more to "True" blocks immediate scheduling of the operation.
       Then multiple writes TO FIELDS LOCATED IN THE SAME REGISTER
       are accumulated. The last call must have "more" set to False.
       It schedules the resulting read-modify-write command.
dispatch(self) - executes the accumulated list of operations
      (the list may be executed automatically, if it grows
      to its full possible length).
"""
from typing import Callable, Any
class BitField(object):
    """Class delivering an object used to describe the bitfield.

    Its fields contain certain precalculated values supporting quick
    handling of read and write access to the field.
    That class does not provide any methods.
    Only fields are used.
    """

    def __init__(self, msb:int, lsb:int, is_signed:bool) -> None:
        self.lsb = lsb
        self.msb = msb
        if is_signed:
            self.sign_mask = 1 << (msb - lsb)
            self.vmin = -self.sign_mask
            self.vmax = self.sign_mask - 1
        else:
            self.vmin = 0
            self.vmax = (1 << (msb - lsb + 1)) - 1
            self.sign_mask = 0
        self.mask = ((1 << (msb + 1)) - 1) ^ ((1 << lsb) - 1)

class _BitFieldFuture(object):
    """Class enabling delayed access to the value read from the bitfield
    """
    def __init__(self, rfut, bf):
        self.rfut = rfut
        self.bf = bf

    def val(self):
        rval = self.rfut() & self.bf.mask
        rval >>= self.bf.lsb
        if self.bf.sign_mask:
            if rval & self.bf.sign_mask:
                rval -= self.bf.sign_mask << 1
        return rval

class _BitFieldAccess(object):
    """Class providing a versatile object supporting  read/write access to any bitfield.

    The details of the particular bitfield are hidden in the
    BitField object passed via bf argument.
    """

    def __init__(self, iface, base, bf):
        self.x__iface = iface
        self.x__base = base
        self.x__bf = bf

    def readf(self) -> int:
        """ Simple read method. Does not use any access optimization.
            The read is performed immediately, the result is
            masked, shifted and returned as integer.
        """
        rval = self.x__iface.read(self.x__base)
        rval &= self.x__bf.mask
        rval >>= self.x__bf.lsb
        if self.x__bf.sign_mask:
            if rval & self.x__bf.sign_mask:
                rval -= self.x__bf.sign_mask << 1
        return rval

    def writef(self, value:int) -> None:
        """ Simple write method. Does not use any access optimization.
            The write is performed immediately.
            Please note, that access to each bitfield generates
            a strobe pulse for the whole register (if strobe is implemented).
        """
        # Check if the value to be stored is correct
        if (value < self.x__bf.vmin) or (value > self.x__bf.vmax):
            raise Exception("Value doesn't fit in the bitfield")
        # If the bitfield is signed, convert the negative values
        if self.x__bf.sign_mask:
            if value < 0:
                value += self.x__bf.sign_mask << 1
                #print("final value: " + str(value))
        value = value << self.x__bf.lsb
        self.x__iface.write_masked(self.x__base, self.x__bf.mask, value)

    def readfb(self) -> Callable[[],int]:
        """ Optimized read method. Schedules reading of the register.
            The "Callable" object is returned.
            When the returned object is called,
            The read is performed immediately (if not dispatched yet),
            and the result is masked, shifted and returned.
        """
        rval = self.x__iface.readb(self.x__base)
        return _BitFieldFuture(rval,self.x__bf).val

    def writefb(self, value:int, more:bool=False) -> None:
        """ Optimized write method. The write is translated into the
            rmw command. Multiple writefb commands to bitfields located
            in the same register are aggregated into a single rmw,
            as long as "more" is True.
            Reading of the register is scheduled after the first writefb
            is executed.
            If "more" is False, the writefb is completed and the write 
            is scheduled with the aggregated masks and values.
            As long as writefb is not complete, other operations
            on the interface raise the exception.

        """
        # Check if the value to be stored is correct
        if (value < self.x__bf.vmin) or (value > self.x__bf.vmax):
            raise Exception("Value doesn't fit in the bitfield")
        # If the bitfield is signed, convert the negative values
        if self.x__bf.sign_mask:
            if value < 0:
                value += self.x__bf.sign_mask << 1
                #print("final value: " + str(value))
        # Calculate the shifted value
        value = value << self.x__bf.lsb
        # Schedule the masked write operation
        self.x__iface.writeb_masked(self.x__base, self.x__bf.mask, value, more)

class Vector(object):
    """Class describing the vector of registers or subblocks.

    It provides only a __getitem__ method that allows to access the particular object
    in a vector (the object is created on the fly, when it is needed).
    """

    def __init__(self, iface, base, nitems, margs):
        self.iface = iface
        self.base = base
        self.mclass = margs[0]
        self.args = None
        if len(margs) > 1:
            self.args = margs[1]
        self.nitems = nitems

    def __getitem__(self, key):
        if isinstance(key,slice):
            return [self[i] for i in range(*key.indices(len(self)))]
        if key < 0:
            key = self.nitems + key
        if key >= self.nitems:
            raise IndexError
        if self.args != None:
            return self.mclass(
                self.iface, self.base + key * self.mclass.x__size, self.args
            )
        return self.mclass(self.iface, self.base + key * self.mclass.x__size)

    def __len__(self):
        return self.nitems

class Block(object):
    """Class describing the blocks handled by addr_gen_wb-generated code.

    The Python backend generates derived classes, with class fields
    corresponding to subblocks or registers.
    """

    x__is_blackbox:bool = False
    x__size:int = 1
    x__fields:dict = {}

    def __init__(self, iface, base):
        """base is the base address for the given block. """
        self.x__base = base
        self.x__iface = iface

    def __dir__(self):
        return self.x__fields.keys()

    def __getattr__(self, name):
        try:
            f_i = self.x__fields[name]
            if len(f_i) == 3:
                return Vector(self.x__iface, self.x__base + f_i[0], f_i[1], f_i[2])
            elif len(f_i) == 2:
                if len(f_i[1]) == 1:
                    return f_i[1][0](self.x__iface, self.x__base + f_i[0])
                # pass addititional argument to the constructor
                return f_i[1][0](self.x__iface, self.x__base + f_i[0], f_i[1][1])
        except KeyError as ke:
            return object.__getattribute__(self,name)

    def _verify_id(self):
        id = self.ID.read()
        if id != self.x__id:
            raise Exception(
                self.__class__.__name__ + " has ID " + hex(self.x__id) + ", read ID " + hex(id)
            )

    def _verify_ver(self):
        ver = self.VER.read()
        if ver != self.x__ver:
            raise Exception(
                self.__class__.__name__ + " has VER " + hex(self.x__ver) + ", read VER " + hex(ver)
            )

    def verify_id_and_version(self):
        """Read and verify id (ID) and version (VER) registers values.

        This function reads and verifies ID and VER register values
        in a recursive way for all non black box blocks.
        It raises the exception if read values differ as it indicates,
        that software and firmware versions differ.
        """
        for k in self.x__fields.keys():
            subblock = getattr(self, k)
            if not issubclass(type(subblock), Block):
                continue

        if self.x__is_blackbox == False:
            self._verify_id()
            self._verify_ver()

    def dispatch(self):
        self.x__iface.dispatch()

class _Register(object):
    """Base class supporting access to the register."""

    x__size = 1

    def __init__(self, iface, base, bfields={}):
        self.x__iface = iface
        self.x__base = base
        self.x__bfields = bfields

    def __dir__(self):
        return self.x__bfields.keys()

    def read(self) -> int:
        """ Simple read method. Does not use any access optimization.
            The read is performed immediately, the result is
            masked, shifted and returned as integer.
        """
        return self.x__iface.read(self.x__base)

    def readb(self) -> Callable[[],int]:
        """ Optimized read method. Schedules reading of the register.
            The "Callable" object is returned.
            When the returned object is called, the read is performed
            immediately (if not dispatched yet), and the result
            is returned as an integer.
        """
        return self.x__iface.readb(self.x__base)

    def read_fifo(self, count:int):
        return self.x__iface.read_fifo(self.x__base, count)

    def write(self, value:int) -> None:
        """ Simple write method. Does not use any access optimization.
            The write is performed immediately.
            Please note, that access to each bitfield generates
            a strobe pulse for the whole register (if strobe is implemented).
        """
        self.x__iface.write(self.x__base, value)

    def writeb(self, value:int) -> None:
        """ Optimized write method. The write is only scheduled.
            It will be executed after the next "dispatch" call,
            or if the maximum length of the scheduled operations' list is
            achieved.
        """
        self.x__iface.writeb(self.x__base, value)

    def write_fifo(self, values):
        self.x__iface.write(self.x__base, values)

    def write_masked(self, mask:int, value:int) -> None:
        """ Executes the read-modify-write method.
            X := (X & ^mask) | (value & mask)
        """
        self.x__iface.write_masked(self.x__base, mask, value)

    def writeb_masked(self, mask:int, value:int, more:bool=False) -> None:
        """ Prepares the read-modify-write operation defined as follows
            X:= (X and ~mask) | (value and mask)
            Setting more to "True" blocks immediate scheduling of the operation.
            Then multiple writes TO FIELDS LOCATED IN THE SAME REGISTER
            are accumulated. The last call must have "more" set to True.
            It schedules the resulting read-modify-write command.
        """
        self.x__iface.writeb_masked(self.x__base, mask, value, more)

    def dispatch(self):
        self.x__iface.dispatch()

    def __getattr__(self, name:str) -> Any:
        try:
            return _BitFieldAccess(self.x__iface, self.x__base, self.x__bfields[name])
        except KeyError as ke:
            return object.__getattribute__(self,name)


ControlRegister = _Register  # The control register is just the generic register


class StatusRegister(_Register):
    """Class supporting access to the read-only (status) register.

    The write methods throws an exception.
    """

    def write(self, value:int) -> None:
        raise Exception("Status register at " + hex(self.x__base) + " can't be written")

    def writeb(self, value:int) -> None:
        raise Exception("Status register at " + hex(self.x__base) + " can't be written")

    def write_masked(self, mask:int, value:int) -> None:
        raise Exception("Status register at " + hex(self.x__base) + " can't be written")

"""
Below is the demo code, showing an example how we may access the registers
via an emulated interface.
Please remember that in the real solution the functionality will be split
into two parts: in the HW backend, and in the gateway application.
"""
if __name__ == "__main__":
    # Table emulating the register file
    rf = 1024 * [
        int(0),
    ]

    # The class iface implements the basic (read, write) 
    # and the extended (readb, writeb, write_maske, writeb_masked, dispatch) methods
    class DemoIface(object):
        def __init__(self):
            self.opers = [] # List of operations
            self.rmw_addr = None # RMW address for aggregated RMW commands
            self.rmw_mask = 0 # Mask for the aggregated RMW commands
            self.rmw_nval = 0 # Value for the aggregated RMW commands
            pass

        class DI_future(object):
            def __init__(self,iface):
                self.iface = iface
                self.done = False
                self._val = None
            def val(self):
                # Check if the transaction is executed
                if self.done:
                    return self._val
                else:
                    self.iface.dispatch()
                    if self.done:
                        return self._val
                    else:
                        raise Exception("val not set after dispatch!")
            def set(self, val):
                self.done = True
                self._val = val

        def read(self, addr:int) -> int:
            self._check_wbm() # Test for uncompleted writeb_masked
            if self.opers:
                self.dispatch()
            return self._read(addr)

        def _read(self, addr):
            global rf
            print("reading from address:" + hex(addr) + " val=" + hex(rf[addr]))
            return rf[addr]

        def write(self, addr:int, val:int) -> None:
            self._check_wbm() # Test for uncompleted writeb_masked
            if self.opers:
                self.dispatch()
            self._write(addr,val)

        def _write(self, addr, val):
            global rf
            print("writing " + hex(val) + " to address " + hex(addr))
            rf[addr] = val

        def writeb(self, addr:int, val:int) -> None:
            self._check_wbm() # Test for uncompleted writeb_masked
            self.opers.append(lambda : self._write(addr, val))

        def readb(self, addr:int) -> Callable[[],int]:
            self._check_wbm() # Test for uncompleted writeb_masked
            df = self.DI_future(self)
            self.opers.append(lambda : df.set(self._read(addr)))
            return df.val

        def _rmw(self, addr, mask, nval):
            # The real HW implemented RMW (now emulated with read and write)
            self._check_wbm() # Test for uncompleted writeb_masked
            print("start RMW (will be done in HW)")
            dval = self._read(addr)
            dval &= ~mask
            dval |= (nval & mask)
            self._write(addr, dval)
            print("finished RMW (done in HW)")

        def write_masked(self, addr:int, mask:int, data:int) -> None:
            self._check_wbm() # Test for uncompleted writeb_masked
            self.opers.append(lambda : self._rmw(addr, mask, data))

        def _check_wbm(self):
            if (self.rmw_addr is not None):
                raise Exception("Another operation can't be done when writeb_masked is not completed")

        def writeb_masked(self, addr:int, mask:int, val:int, more:bool = False):
            # Check if another RMW was not completed
            if (self.rmw_addr is not None) and (addr != self.rmw_addr):
                raise Exception("aggregated writeb_masked must use the same address")

            if self.rmw_addr is None:
                self.rmw_addr = addr
                self.rmw_mask = mask
                self.rmw_nval = val
            else:
                self.rmw_mask |= mask
                self.rmw_nval &= ~mask
                self.rmw_nval |= (val & mask)
            if not more:
                # Schedule reading of the initial value of the register
                addr = self.rmw_addr
                mask = self.rmw_mask
                nval = self.rmw_nval
                self.opers.append(lambda : self._rmw(addr, mask, nval))
                self.rmw_addr = None

        def dispatch(self):
            if not self.opers:
                print("empty dispatch")
                return
            print("before dispatch")
            for x in self.opers:
                x()
            self.opers = []
            print("after dispatch")


    class c2(Block):
        x__size = 3
        x__fields = {
            "r1": (
                1,
                (
                    StatusRegister,
                    {"t1": BitField(3, 1, False), "t2": BitField(9, 4, False),},
                ),
            )
        }

    class regs(Block):
        x__size:int = 4
        x__fields:dict = {
           "rv" : (
             1,
             (
                ControlRegister, {},
             ),
           )
        }

    class c1(Block):
        x__size = 100
        x__fields = {
            "f1": (0, 10, (c2,)),
            "f2": (11, (c2,)),
            "size": (32, (c2,)),
            "x1":(40,5,(regs,)),
            }

    mf = DemoIface()
    a = c1(mf, 12)

    # Check if two consecutive BF writes do not interfere
    a.f1[0].r1.t2.writefb(11,True)
    print("1")
    a.f1[0].r1.t1.writefb(5)
    print("2")
    a.f2.r1.t1.writefb(7,False)
    print("3")
    a.f2.r1.t2.writef(13)
    a.x1[3].rv.write(5)
    a.x1[1].rv.write(7)
    p1 = a.f1[0].r1.t2.readfb()
    p2 = a.f1[0].r1.t1.readfb()
    a.x1[1].rv.writeb_masked(3<<10,0xffffff)
    p2b = a.x1[1].rv.readb()
    a.dispatch()
    print(p1(),p2(), hex(p2b()))
    p3 = a.x1[1].rv.readb()
    p4 = a.x1[3].rv.readb()
    print(p3(),p4())
    print(a.f2.r1.t2.readf())
    print(a.f2.r1.t1.readf())
    a.dispatch()
